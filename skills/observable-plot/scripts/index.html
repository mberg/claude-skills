<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Observable Plot Viewer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      height: 100vh;
      overflow: hidden;
      background: #1e1e1e;
    }

    .container {
      display: flex;
      height: 100vh;
      width: 100vw;
    }

    .history-pane {
      width: 250px;
      display: flex;
      flex-direction: column;
      background: #252526;
      border-right: 2px solid #333;
      overflow: hidden;
    }

    .viewer-pane {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #ffffff;
      overflow: auto;
    }

    .editor-pane {
      flex: 1;
      display: flex;
      flex-direction: column;
      border-left: 2px solid #333;
    }

    .history-header {
      background: #2d2d30;
      color: #cccccc;
      padding: 8px 16px;
      font-size: 13px;
      font-weight: 600;
      border-bottom: 1px solid #3e3e42;
    }

    .history-list {
      flex: 1;
      overflow-y: auto;
      padding: 8px 0;
    }

    .history-item {
      padding: 8px 16px;
      cursor: pointer;
      border-left: 3px solid transparent;
      transition: all 0.2s;
    }

    .history-item:hover {
      background: #2a2d2e;
      border-left-color: #0e639c;
    }

    .history-item.active {
      background: #37373d;
      border-left-color: #0e639c;
    }

    .history-item-name {
      color: #cccccc;
      font-size: 13px;
      font-weight: 500;
      margin-bottom: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .history-item-desc {
      color: #858585;
      font-size: 11px;
      margin-bottom: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .history-item-time {
      color: #6a6a6a;
      font-size: 10px;
    }

    .history-empty {
      color: #858585;
      font-size: 12px;
      padding: 16px;
      text-align: center;
    }

    .plots-dir-info {
      background: #1e1e1e;
      padding: 12px 16px;
      border-bottom: 1px solid #3e3e42;
      font-size: 11px;
      color: #858585;
    }

    .plots-dir-label {
      color: #6a6a6a;
      text-transform: uppercase;
      font-size: 10px;
      margin-bottom: 4px;
    }

    .plots-dir-path {
      color: #cccccc;
      font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
      word-break: break-all;
      line-height: 1.4;
    }

    .plots-dir-error {
      color: #f48771;
      margin-top: 4px;
    }

    .file-count {
      color: #4a9eff;
      margin-top: 8px;
    }

    .toolbar {
      background: #2d2d30;
      color: #cccccc;
      padding: 8px 16px;
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 13px;
      border-bottom: 1px solid #3e3e42;
    }

    .toolbar-title {
      font-weight: 600;
    }

    .toolbar-button {
      background: #0e639c;
      color: white;
      border: none;
      padding: 4px 12px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 12px;
    }

    .toolbar-button:hover {
      background: #1177bb;
    }

    .status {
      margin-left: auto;
      font-size: 11px;
      color: #858585;
    }

    .status.error {
      color: #f48771;
    }

    .status.success {
      color: #89d185;
    }

    #chart-container {
      flex: 1;
      padding: 20px;
      overflow: auto;
    }

    #editor {
      flex: 1;
      height: 100%;
    }

    .error-display {
      background: #5a1d1d;
      color: #f48771;
      padding: 12px 16px;
      font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
      font-size: 12px;
      white-space: pre-wrap;
      max-height: 150px;
      overflow-y: auto;
      border-bottom: 1px solid #8b0000;
    }

    .resizer {
      width: 4px;
      background: #333;
      cursor: col-resize;
      transition: background 0.2s;
    }

    .resizer:hover {
      background: #0e639c;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="history-pane">
      <div class="history-header">Plot History</div>
      <div class="plots-dir-info" id="plots-dir-info">
        <div class="plots-dir-label">Plots Directory</div>
        <div class="plots-dir-path" id="plots-dir-path">Loading...</div>
        <div class="file-count" id="file-count"></div>
      </div>
      <div class="history-list" id="history-list">
        <div class="history-empty">No plots yet</div>
      </div>
    </div>

    <div class="viewer-pane">
      <div class="toolbar">
        <span class="toolbar-title">Chart Preview</span>
        <span class="status" id="viewer-status" style="margin-left: auto;"></span>
      </div>
      <div id="error-container"></div>
      <div id="chart-container"></div>
    </div>

    <div class="resizer" id="resizer"></div>

    <div class="editor-pane">
      <div class="toolbar">
        <span class="toolbar-title">Code Editor</span>
        <button class="toolbar-button" onclick="document.getElementById('file-input').click()">Load File</button>
        <input type="file" id="file-input" accept=".json" style="display: none;" onchange="handleFileUpload(event)">
        <span class="status" id="editor-status"></span>
      </div>
      <div id="editor"></div>
    </div>
  </div>

  <!-- D3 and Observable Plot (load before Monaco to avoid module conflicts) -->
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>

  <!-- Monaco Editor -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/loader.min.js"></script>

  <script>
    let editor;
    let debounceTimeout;
    let librariesReady = false;
    let lastMtime = null;
    let currentPlotFilename = null;
    let plotMtimes = new Map(); // Track modification times of all plot files

    // Send errors to server for debugging
    function reportError(message, stack = '') {
      try {
        fetch('/error', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ message, stack })
        }).catch(err => console.error('Failed to report error:', err));
      } catch (e) {
        console.error('Error reporting failed:', e);
      }
    }

    // Catch global errors
    window.addEventListener('error', (event) => {
      reportError(event.message, event.error?.stack || '');
    });

    window.addEventListener('unhandledrejection', (event) => {
      reportError(`Unhandled promise rejection: ${event.reason}`, event.reason?.stack || '');
    });

    // Load Observable Plot as ES module
    import('https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm').then(PlotModule => {
      window.Plot = PlotModule;
      librariesReady = true;
      console.log('Plot library loaded');
    }).catch(err => {
      console.error('Failed to load Plot:', err);
    });

    // Initialize Monaco Editor
    require.config({ paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs' } });

    require(['vs/editor/editor.main'], function () {
      editor = monaco.editor.create(document.getElementById('editor'), {
        value: '// Loading code from temp file...',
        language: 'javascript',
        theme: 'vs-dark',
        fontSize: 13,
        minimap: { enabled: false },
        scrollBeyondLastLine: false,
        automaticLayout: true,
        tabSize: 2,
        wordWrap: 'on'
      });

      // Auto-evaluate on change with debouncing
      editor.onDidChangeModelContent(() => {
        clearTimeout(debounceTimeout);
        document.getElementById('editor-status').textContent = 'Editing...';
        debounceTimeout = setTimeout(() => {
          evaluateCode();
        }, 500);
      });

      // Keyboard shortcuts
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {
        evaluateCode();
      });

      // Load temp file on startup
      loadFromTempFile();

      // Load plots directory info
      loadPlotsDirectory();

      // Load plot history
      loadPlotHistory();

      // Poll for temp file changes and history updates
      setInterval(async () => {
        try {
          const response = await fetch('/code-mtime');
          const data = await response.json();
          if (data.mtime && data.mtime !== lastMtime) {
            lastMtime = data.mtime;
            console.log('Current plot changed, reloading...');
            loadFromTempFile();
          }
        } catch (err) {
          console.error('Error polling for file changes:', err);
        }
      }, 1000);

      // Poll for history updates to detect file changes
      setInterval(loadPlotHistory, 2000);
    });

    function getDefaultCode() {
      return `// Observable Plot Example
// Available: Plot, d3
// The plot will be automatically displayed

const data = [
  { x: 1, y: 2, category: "A" },
  { x: 2, y: 5, category: "B" },
  { x: 3, y: 3, category: "A" },
  { x: 4, y: 8, category: "B" },
  { x: 5, y: 6, category: "A" }
];

return Plot.plot({
  marks: [
    Plot.dot(data, {
      x: "x",
      y: "y",
      fill: "category",
      r: 8,
      tip: true
    }),
    Plot.ruleY([0])
  ],
  color: { legend: true }
})`;
    }

    function clearChart() {
      document.getElementById('chart-container').innerHTML = '';
      document.getElementById('error-container').innerHTML = '';
      updateStatus('viewer-status', 'Cleared', 'success');
    }

    async function evaluateCode() {
      const code = editor.getValue();
      const chartContainer = document.getElementById('chart-container');
      const errorContainer = document.getElementById('error-container');

      // Clear previous content
      chartContainer.innerHTML = '';
      errorContainer.innerHTML = '';

      // Check if Plot and d3 are loaded
      if (typeof window.d3 === 'undefined' || typeof window.Plot === 'undefined') {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-display';
        const d3Status = typeof window.d3 === 'undefined' ? 'waiting' : 'loaded';
        const plotStatus = typeof window.Plot === 'undefined' ? 'waiting' : 'loaded';
        errorDiv.textContent = `Loading libraries... (d3: ${d3Status}, Plot: ${plotStatus})`;
        errorContainer.appendChild(errorDiv);
        setTimeout(() => evaluateCode(), 1000);
        return;
      }

      try {
        // Create async function with Plot and d3 passed in
        // Code should contain explicit "return" statement or end with an expression
        const plotFunction = new Function('Plot', 'd3', `return (async () => { ${code} })()`);
        const result = await plotFunction(window.Plot, window.d3);

        if (result && typeof result === 'object') {
          // If it's a Plot result, append it
          chartContainer.appendChild(result);
          const now = new Date();
          const timeString = now.toLocaleTimeString();
          updateStatus('viewer-status', `Updated by Claude • ${timeString}`, '');
        } else {
          throw new Error('Code must return a Plot.plot() result. Use "return Plot.plot(...)" or ensure the last expression is a plot.');
        }
      } catch (error) {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-display';
        errorDiv.textContent = `Error: ${error.message}\n${error.stack || ''}`;
        errorContainer.appendChild(errorDiv);

        updateStatus('viewer-status', '', '');

        // Report error to server for debugging
        reportError(`Plot evaluation error: ${error.message}`, error.stack || '');
      }
    }

    function updateStatus(elementId, message, status) {
      const element = document.getElementById(elementId);
      element.textContent = message;
      element.className = 'status ' + status;
    }

    async function loadFromTempFile() {
      try {
        updateStatus('editor-status', 'Loading temp file...', '');
        const response = await fetch('/code');
        if (!response.ok) {
          throw new Error('Failed to load temp file');
        }
        const code = await response.text();
        if (code && code.trim() && !code.startsWith('// No code file')) {
          editor.setValue(code);
          evaluateCode();
          updateStatus('editor-status', 'Loaded from temp file', 'success');
        } else {
          updateStatus('editor-status', 'No code in temp file', 'error');
        }
      } catch (error) {
        updateStatus('editor-status', `Error: ${error.message}`, 'error');
      }
    }

    function handleFileUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const json = JSON.parse(e.target.result);
          const code = json.code || JSON.stringify(json, null, 2);
          editor.setValue(code);
          evaluateCode();
        } catch (error) {
          const errorDiv = document.createElement('div');
          errorDiv.className = 'error-display';
          errorDiv.textContent = `Error parsing JSON: ${error.message}`;
          document.getElementById('error-container').appendChild(errorDiv);
        }
      };
      reader.readAsText(file);
      // Reset file input so same file can be loaded again
      event.target.value = '';
    }

    async function loadPlotsDirectory() {
      try {
        console.log('Fetching plots directory info...');
        const response = await fetch('/plots-dir');
        if (!response.ok) {
          console.error('Failed to fetch plots-dir:', response.status);
          return;
        }

        const data = await response.json();
        console.log('Plots directory data:', data);
        const pathElement = document.getElementById('plots-dir-path');
        const fileCountElement = document.getElementById('file-count');

        if (data.error) {
          pathElement.innerHTML = `<div class="plots-dir-error">Error: ${data.error}</div>`;
          return;
        }

        pathElement.textContent = data.plots_dir || 'Unknown';

        if (!data.exists) {
          pathElement.innerHTML += '<div class="plots-dir-error">⚠ Directory does not exist</div>';
        }
      } catch (error) {
        console.error('Error loading plots directory:', error);
        document.getElementById('plots-dir-path').innerHTML =
          '<div class="plots-dir-error">Error loading directory info</div>';
      }
    }

    async function loadPlotHistory() {
      try {
        console.log('Fetching plot history...');
        const response = await fetch('/plots');
        if (!response.ok) {
          console.error('Failed to fetch plots:', response.status);
          return;
        }

        const plots = await response.json();
        console.log('Plots data:', plots);
        const historyList = document.getElementById('history-list');
        const fileCountElement = document.getElementById('file-count');

        // Check if current file was modified
        if (currentPlotFilename) {
          const currentPlot = plots.find(p => p.filename === currentPlotFilename);
          if (currentPlot) {
            const oldMtime = plotMtimes.get(currentPlotFilename);
            if (oldMtime && currentPlot.mtime !== oldMtime) {
              console.log('Current plot file changed, reloading:', currentPlotFilename);
              // Reload the plot automatically
              loadPlot(currentPlotFilename, true);
            }
          }
        }

        // Update mtime tracking
        plots.forEach(plot => {
          plotMtimes.set(plot.filename, plot.mtime);
        });

        // Update file count
        if (plots && plots.length > 0) {
          fileCountElement.textContent = `${plots.length} file${plots.length !== 1 ? 's' : ''} found`;
        } else {
          fileCountElement.textContent = '0 files found';
        }

        if (!plots || plots.length === 0) {
          historyList.innerHTML = '<div class="history-empty">No plots yet</div>';
          plotMtimes.clear();
          return;
        }

        console.log('Rendering', plots.length, 'plots');
        historyList.innerHTML = '';
        plots.forEach(plot => {
          console.log('Rendering plot:', plot.name);
          const item = document.createElement('div');
          item.className = 'history-item';
          if (plot.filename === currentPlotFilename) {
            item.classList.add('active');
          }

          const name = document.createElement('div');
          name.className = 'history-item-name';
          name.textContent = plot.name || plot.filename;

          const desc = document.createElement('div');
          desc.className = 'history-item-desc';
          desc.textContent = plot.description || 'No description';

          const time = document.createElement('div');
          time.className = 'history-item-time';
          const date = new Date(plot.timestamp);
          time.textContent = date.toLocaleString();

          item.appendChild(name);
          item.appendChild(desc);
          item.appendChild(time);

          item.addEventListener('click', () => loadPlot(plot.filename));

          historyList.appendChild(item);
        });
      } catch (error) {
        console.error('Error loading plot history:', error);
      }
    }

    async function loadPlot(filename, isAutoReload = false) {
      try {
        if (!isAutoReload) {
          updateStatus('editor-status', 'Loading plot...', '');
        }
        const response = await fetch(`/plot/${filename}`);
        if (!response.ok) {
          throw new Error('Failed to load plot');
        }

        const data = await response.json();
        if (data.error) {
          throw new Error(data.error);
        }

        currentPlotFilename = filename;
        editor.setValue(data.code || '');
        evaluateCode();

        if (isAutoReload) {
          updateStatus('editor-status', `Auto-reloaded: ${data.name || filename}`, 'success');
        } else {
          updateStatus('editor-status', `Loaded: ${data.name || filename}`, 'success');
          // Only refresh history list if this was a manual load (avoid infinite loop)
          loadPlotHistory();
        }
      } catch (error) {
        updateStatus('editor-status', `Error: ${error.message}`, 'error');
      }
    }

    function loadExample() {
      const examples = [
        {
          name: "Scatterplot with Regression",
          code: `// Scatterplot with Linear Regression
const data = Array.from({length: 50}, () => ({
  x: Math.random() * 100,
  y: 20 + Math.random() * 60 + Math.random() * 20
}));

Plot.plot({
  marks: [
    Plot.dot(data, {
      x: "x",
      y: "y",
      fill: "steelblue",
      r: 4
    }),
    Plot.linearRegressionY(data, {
      x: "x",
      y: "y",
      stroke: "red",
      strokeWidth: 2
    }),
    Plot.ruleY([0])
  ],
  grid: true
})`
        },
        {
          name: "Stacked Bar Chart",
          code: `// Stacked Bar Chart
const data = [
  {quarter: "Q1", product: "A", revenue: 100},
  {quarter: "Q1", product: "B", revenue: 80},
  {quarter: "Q2", product: "A", revenue: 120},
  {quarter: "Q2", product: "B", revenue: 95},
  {quarter: "Q3", product: "A", revenue: 110},
  {quarter: "Q3", product: "B", revenue: 105},
  {quarter: "Q4", product: "A", revenue: 140},
  {quarter: "Q4", product: "B", revenue: 115}
];

Plot.plot({
  marks: [
    Plot.barY(data, Plot.stackY({
      x: "quarter",
      y: "revenue",
      fill: "product"
    })),
    Plot.ruleY([0])
  ],
  color: { legend: true }
})`
        },
        {
          name: "Hexbin Heatmap",
          code: `// Hexbin Heatmap
const data = Array.from({length: 2000}, () => ({
  x: Math.random() * 100,
  y: Math.random() * 100
}));

Plot.plot({
  color: {
    scheme: "YlOrRd",
    legend: true,
    label: "Density"
  },
  marks: [
    Plot.dot(data, Plot.hexbin(
      {fill: "count"},
      {
        x: "x",
        y: "y",
        binWidth: 8,
        r: 6,
        stroke: "white",
        strokeWidth: 0.5
      }
    ))
  ]
})`
        }
      ];

      const example = examples[Math.floor(Math.random() * examples.length)];
      editor.setValue(example.code);
      evaluateCode();
    }

    // Resizer functionality
    const resizer = document.getElementById('resizer');
    const viewerPane = document.querySelector('.viewer-pane');
    const editorPane = document.querySelector('.editor-pane');
    let isResizing = false;

    resizer.addEventListener('mousedown', (e) => {
      isResizing = true;
      document.body.style.cursor = 'col-resize';
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!isResizing) return;

      const containerWidth = document.querySelector('.container').offsetWidth;
      const viewerWidth = (e.clientX / containerWidth) * 100;

      if (viewerWidth > 20 && viewerWidth < 80) {
        viewerPane.style.flex = `0 0 ${viewerWidth}%`;
        editorPane.style.flex = `0 0 ${100 - viewerWidth}%`;
      }
    });

    document.addEventListener('mouseup', () => {
      if (isResizing) {
        isResizing = false;
        document.body.style.cursor = 'default';
      }
    });
  </script>
</body>
</html>
